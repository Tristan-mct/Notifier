<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>notifbot.notifbot API documentation</title>
<meta name="description" content="Created on Sat Apr 27 18:02:18 2019 …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>notifbot.notifbot</code></h1>
</header>
<section id="section-intro">
<p>Created on Sat Apr 27 18:02:18 2019.</p>
<p>@author: Tristan Muscat</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
&#34;&#34;&#34;
Created on Sat Apr 27 18:02:18 2019.

@author: Tristan Muscat
&#34;&#34;&#34;
# =====================================================================================================================
# Import et librairies
# =====================================================================================================================
import json
import os
import time
from typing import Any
from typing import Optional

import inputmanager as im
import numpy as np
import requests
from fuzzywuzzy import process
from slack_progress import SlackProgress
from typing_extensions import SupportsIndex

# =====================================================================================================================
# Slackbot specific errors.
# =====================================================================================================================


class SlackbotException(Exception):
    &#34;&#34;&#34;Slackbot erros.&#34;&#34;&#34;

    def __init__(self, message):
        &#34;&#34;&#34;Error constructor.&#34;&#34;&#34;
        super(Exception, self).__init__(message)


# =============================================================================
# Hybrid methods
# =============================================================================


class hybridmethod:
    &#34;&#34;&#34;Allow to declare a class and instance version of the same method.&#34;&#34;&#34;

    def __init__(self, fclass, finstance=None, doc=None):
        self.fclass = fclass
        self.finstance = finstance
        self.__doc__ = doc or fclass.__doc__
        # support use on abstract base classes
        self.__isabstractmethod__ = bool(getattr(fclass, &#34;__isabstractmethod__&#34;, False))

    def classmethod(self, fclass):
        &#34;&#34;&#34;Class method version of the function.&#34;&#34;&#34;
        return type(self)(fclass, self.finstance, None)

    def instancemethod(self, finstance):
        &#34;&#34;&#34;Instance method version of the function.&#34;&#34;&#34;
        return type(self)(self.fclass, finstance, self.__doc__)

    def __get__(self, instance, cls):
        &#34;&#34;&#34;Retreive the right version.&#34;&#34;&#34;
        if instance is None or self.finstance is None:
            # either bound to the class, or no instance method available
            return self.fclass.__get__(cls, None)
        return self.finstance.__get__(instance, cls)


# =====================================================================================================================
# Slack notification interface.
# =====================================================================================================================


class NotifBot:
    &#34;&#34;&#34;Pour créer un objet de notifications.

    Class Attributes
    ----------------
    str_botauth: str
        Slack Bot Authentification Token. Retreived from environement variables.
    dict_headers: dict
        Simple formatted header used to querry slack API.

    Instance Attributes
    -------------------
    lst_users: list
        A list of all users and associated channels, also public channels. Each user is represented in a dictionnary
        with basic information and the ID used to send a message.
    dict_sbars: dict
        A dictionnary used to store and manage multiple progress bars.
    &#34;&#34;&#34;

    str_botauth: str = os.environ[&#34;BOTAUTH_TOKEN&#34;]
    dict_headers: dict[str, str] = {
        &#34;Authorization&#34;: f&#34;Bearer {str_botauth}&#34;,
        &#34;Content-type&#34;: &#34;application/json&#34;,
    }

    # =====================================================================================================================
    # Initialisation.
    # =====================================================================================================================

    def __init__(self):
        &#34;&#34;&#34;Initialize a notifier.

        Creating an instance of a notifier instead of using exclusively class methods allow to keep track of
        progress bars, and also load the list of users and channels only once.
        &#34;&#34;&#34;
        # Initialisation of the attributes.
        self.lst_users: list[dict[Any, Any]] = list()
        self.dict_sbars: dict[str, Any] = {}

        # Setting the user list.
        self._set_users()
        self._set_channels()
        self._set_public_channels()

    # =====================================================================================================================
    # Simple class method to send a message
    # =====================================================================================================================

    @hybridmethod
    def notify(cls, str_message: str, str_channel: str, str_user: Optional[str] = None) -&gt; None:
        &#34;&#34;&#34;Allow to send a message via the slack API.

        This is a classmethod, it can be used to send a one-shot notification. More complex usage should require
        to declare an instance NotifBot. The &#39;str_user&#39; is here because hybridmethods need to have the same arguments
        for all their versions, but it cannot be used in the class method version.

        Parameters
        ----------
        str_message: str
            The message to send.
        str_channel: str
            The specific ID of the channel where to send the message.
        str_user: str
            Not in use in this version of the function. Default is None.
        &#34;&#34;&#34;
        data: str = f&#39;{{&#34;channel&#34;:&#34;{str_channel}&#34;, &#34;text&#34;:&#34;{str_message}&#34;}}&#39;
        requests.post(
            &#34;https://slack.com/api/chat.postMessage&#34;,
            headers=NotifBot.dict_headers,
            data=data,
        )

    # =====================================================================================================================
    # Setters / Getters
    # =====================================================================================================================

    def _set_users(self) -&gt; None:
        &#34;&#34;&#34;Initialize the list of users.&#34;&#34;&#34;
        # Getting the users.list from slack API and parsing the result.
        response: requests.models.Response = requests.post(&#34;https://slack.com/api/users.list&#34;, headers=NotifBot.dict_headers)
        res: list[dict[str, Any]] = json.loads(response.content.decode(&#34;utf-8&#34;))[&#34;members&#34;]

        # Storing all important information in a list of dictionnaries.
        self.lst_users = [
            {
                &#34;ID&#34;: elt[&#34;id&#34;],
                &#34;Team_ID&#34;: elt[&#34;team_id&#34;],
                &#34;Name&#34;: elt[&#34;name&#34;],
                &#34;Real_name&#34;: elt[&#34;real_name&#34;],
                &#34;Channel&#34;: np.nan,
            }
            if &#34;real_name&#34; in elt.keys()
            else {
                &#34;ID&#34;: elt[&#34;id&#34;],
                &#34;Team_ID&#34;: elt[&#34;team_id&#34;],
                &#34;Name&#34;: elt[&#34;name&#34;],
                &#34;Real_name&#34;: np.nan,
                &#34;Channel&#34;: np.nan,
            }
            for elt in res
        ]

    def _set_channels(self) -&gt; None:
        &#34;&#34;&#34;Add, for each user, the channel to send them messages.&#34;&#34;&#34;
        # Getting the im.list from the slack API and parsing the result.
        response: requests.models.Response = requests.post(
            &#34;https://slack.com/api/conversations.list?types=im&#34;,
            headers=NotifBot.dict_headers,
        )
        res: list[dict[str, Any]] = json.loads(response.content.decode(&#34;utf-8&#34;))[&#34;channels&#34;]

        lst_channels: list[dict[str, str]] = [{&#34;ID&#34;: elt[&#34;user&#34;], &#34;Channel&#34;: elt[&#34;id&#34;]} for elt in res]

        # For each channel, we look up a user with the same ID, when their is a match, the channel is set
        # in the list of users.
        for channel in lst_channels:
            for user in self.lst_users:
                if user[&#34;ID&#34;] == channel[&#34;ID&#34;]:
                    user[&#34;Channel&#34;] = channel[&#34;Channel&#34;]

    def _set_public_channels(self) -&gt; None:
        &#34;&#34;&#34;Add every public channel.&#34;&#34;&#34;
        # Getting the channels.list from the slack API and parsing the result.
        response: requests.models.Response = requests.post(&#34;https://slack.com/api/conversations.list&#34;, headers=NotifBot.dict_headers)
        res: list[dict[str, Any]] = json.loads(response.content.decode(&#34;utf-8&#34;))[&#34;channels&#34;]

        # Storgin everything in a dictionnary.
        lst_public_channels: list[dict[str, str]] = [
            {
                &#34;ID&#34;: elt[&#34;created&#34;],
                &#34;Name&#34;: elt[&#34;name_normalized&#34;],
                &#34;Real_name&#34;: elt[&#34;name&#34;],
                &#34;Channel&#34;: elt[&#34;id&#34;],
            }
            for elt in res
        ]

        # The dictionnary is added to the list of users, the keys to search and to get a channel ID are the same.
        self.lst_users = self.lst_users + lst_public_channels

    # =====================================================================================================================
    # Getting channels and messages
    # =====================================================================================================================

    def get_list_messages(
        self,
        str_channel: Optional[str] = None,
        str_user: Optional[str] = None,
        bl_public: Optional[bool] = False,
    ) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Retreive the list of messages on a channel. Used mostly to purge a channel.

        Parameters
        ----------
        str_channel : str, optional
            The channel ID. The default is None.
        str_user : str, optional
            The name of the user. The default is None.
        bl_public: boolean
            Is the channel public or not.

        Returns
        -------
        dict_messages : dict
            A dictionnary with every message in the channel.
        &#34;&#34;&#34;
        # If a channel ID is not provided, we use the user name to get a channel ID.
        if str_channel is None:
            str_channel = self.get_user_id(str_user)

        # Retreiving the messages with slack API.
        str_token: str = os.environ[&#34;OAUTH_TOKEN&#34;] if bl_public else NotifBot.str_botauth

        response: requests.models.Response = requests.post(
            f&#34;https://slack.com/api/conversations.history?token={str_token}&amp;channel={str_channel}&#34;
        )
        dict_messages: list[dict[str, Any]] = json.loads(response.content.decode(&#34;utf-8&#34;))[&#34;messages&#34;]

        return dict_messages

    def get_user_id(self, str_user: Optional[str] = None) -&gt; str:
        &#34;&#34;&#34;Get a user&#39;s ID from their name.

        Parameters
        ----------
        str_user : str
            The user&#39;s name.

        Returns
        -------
        str_channel : str
            The channel ID associated to the user.
        &#34;&#34;&#34;
        # We search trough the user list with fuzzysearch, retreiving several possible matchs.
        lst_user_names: list[str] = [elt[&#34;Real_name&#34;] for elt in self.lst_users if isinstance(elt[&#34;Real_name&#34;], str)]
        lst_best_names: list[str] = process.extractBests(str_user, lst_user_names, score_cutoff=80)

        # If we get more than one match, the user is prompted to pick the right one.
        if len(lst_best_names) &gt; 1:
            print(f&#34;Serveral match for the name {str_user}.&#34;)
            for i in range(0, len(lst_best_names)):
                print(f&#34;{str(i + 1)} : {lst_best_names[i][0]}&#34;)
            print(f&#34;{str(i + 2)} : Quit&#34;)
            index_name: int = im.force_read(im.read_numeric, &#34;Your pick : &#34;, True, 1, len(lst_best_names) + 1)
            if index_name == (i + 2):
                raise SlackbotException(f&#34;No match for {str_user} user.&#34;)
            str_user = lst_best_names[index_name - 1][0]
        # If their is only one match, then we get their channel ID.
        elif len(lst_best_names) == 1:
            str_user = lst_best_names[0][0]
        # If no match, then error.
        else:
            raise SlackbotException(f&#34;No match for {str_user} user.&#34;)

        # Looking up the channel ID in the user list.
        str_channel: str = [elt[&#34;Channel&#34;] for elt in self.lst_users if elt[&#34;Real_name&#34;] == str_user][0]

        # If the user exist but no channel is open with them.
        if not isinstance(str_channel, str):
            raise SlackbotException(f&#34;No channel openned with {str_user}.&#34;)

        return str_channel

    # =====================================================================================================================
    # Sending and deleting messages
    # =====================================================================================================================

    @notify.instancemethod
    def notify(
        self,
        str_message: str,
        str_channel: Optional[str] = None,
        str_user: Optional[str] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Send a message to a user or on a channel.

        Parameters
        ----------
        str_message: str
            The message to send.
        str_channel: str
            The ID of the user or the public channel.
        str_user : str
            If the channel ID is unknown then the user&#39;s name can be used to get it.
        &#34;&#34;&#34;
        # If the channel ID is unknown then the user&#39;s name can be used to get it.
        if str_channel is None:
            str_channel = self.get_user_id(str_user)

        # Send a message through the slack API.
        data: str = f&#39;{{&#34;channel&#34;:&#34;{str_channel}&#34;, &#34;text&#34;:&#34;{str_message}&#34;}}&#39;
        requests.post(
            &#34;https://slack.com/api/chat.postMessage&#34;,
            headers=NotifBot.dict_headers,
            data=data,
        )

    def progress(
        self,
        str_name: str,
        str_title: str,
        int_total: int,
        str_channel: Optional[str] = None,
        str_user: Optional[str] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Create a progress bar.

        Parameters
        ----------
        str_name: str
            The name of the progress bar. Used to reference it once created.
        str_title: str
            The displayed title of the progress bar.
        str_channel: str
            The ID of the user or the public channel.
        str_user : str
            If the channel ID is unknown then the user&#39;s name can be used to get it.
        &#34;&#34;&#34;
        # If the channel ID is unknown then the user&#39;s name can be used to get it.
        if str_channel is None:
            str_channel = self.get_user_id(str_user)

        # Adding the progress bar with it&#39;s title and total.
        progress_bar = SlackProgress(NotifBot.str_botauth, str_channel)
        self.dict_sbars[str_name] = {
            &#34;pbar&#34;: progress_bar.new(total=int_total),
            &#34;title&#34;: str_title,
        }
        self.dict_sbars[str_name][&#34;pbar&#34;].log(str_title)

    def progress_set_title(self, str_name: str, str_title: str) -&gt; None:
        &#34;&#34;&#34;Set the progress bar title. Used mostly to change it.

        Parameters
        ----------
        str_name: str
            The name of the progress bar. Used to reference it once created.
        str_title: str
            The displayed title of the progress bar.
        &#34;&#34;&#34;
        self.dict_sbars[str_name][&#34;title&#34;] = str_title

    def progress_update(self, str_name: str, int_value: int) -&gt; None:
        &#34;&#34;&#34;Update a prgress bar.

        Parameters
        ----------
        str_name: str
            The name of the progress bar. Used to reference it once created.
        int_value: int
            The value to add.
        &#34;&#34;&#34;
        self.dict_sbars[str_name][&#34;pbar&#34;].pos = round(
            (self.dict_sbars[str_name][&#34;pbar&#34;].pos + (int_value * 100 / self.dict_sbars[str_name][&#34;pbar&#34;].total)),
            2,
        )

    def progress_value(self, str_name: str, int_value: int):
        &#34;&#34;&#34;Set the progress bar to a specific value.

        Parameters
        ----------
        str_name: str
            The name of the progress bar.
        int_value: int
            The value where to set the progress bar.
        &#34;&#34;&#34;
        self.dict_sbars[str_name][&#34;pbar&#34;].pos = round((int_value * 100 / self.dict_sbars[str_name][&#34;pbar&#34;].total), 2)

    def progress_log(self, str_name: str, str_log: str, bl_stack_log: Optional[bool] = True):
        &#34;&#34;&#34;Log an event into the progress bar (display under the title in slack).

        Parameters
        ----------
        str_name: str
            The name of the progress bar.
        str_log : str
            The message to log.
        bl_stack_log: bool
            Should we erease all previous logged messages.
        &#34;&#34;&#34;
        # The message is added to the progress bar.
        self.dict_sbars[str_name][&#34;pbar&#34;].log(f&#34;{self.dict_sbars[str_name][&#39;title&#39;]} - {str_log}&#34;)

        # If we decide so, every logged message added before the new one is deleted.
        if not bl_stack_log:
            self.dict_sbars[str_name][&#34;pbar&#34;]._msg_log = [self.dict_sbars[str_name][&#34;pbar&#34;]._msg_log[-1]]
            self.dict_sbars[str_name][&#34;pbar&#34;]._update()

    def progress_delete(self, str_name: str) -&gt; None:
        &#34;&#34;&#34;Delete a progress bar.

        Parameters
        ----------
        str_name: str
            The name of the progress bar.
        &#34;&#34;&#34;
        # In order to delete a message (a progress bar in this case), we need its time stamp
        str_ts = self.dict_sbars[str_name][&#34;pbar&#34;].msg_ts
        data = f&#34;&#34;&#34;{{&#34;channel&#34;:&#34;{self.dict_sbars[str_name][&#39;pbar&#39;].channel_id}&#34;, &#34;ts&#34;:&#34;{str_ts}&#34;}}&#34;&#34;&#34;
        requests.post(
            &#34;https://slack.com/api/chat.delete&#34;,
            headers=NotifBot.dict_headers,
            data=data,
        )

    def purge_chat(
        self,
        str_channel: Optional[str] = None,
        str_user: Optional[str] = None,
        bl_public: Optional[bool] = False,
    ) -&gt; None:
        &#34;&#34;&#34;Purge an entier chat.

        Parameters
        ----------
        str_channel: str
            The ID of the user or the public channel.
        str_user : str
            If the channel ID is unknown then the user&#39;s name can be used to get it.
        bl_public: boolean
            Is the channel public or not.
        &#34;&#34;&#34;
        # If the channel ID is unknown then the user&#39;s name can be used to get it.
        if str_channel is None:
            str_channel = self.get_user_id(str_user)

        # Getting the list of all message on the channel.
        lst_messages = self.get_list_messages(str_channel, bl_public=bl_public)

        # For each message, we use its time stamp to delete it.
        for message in lst_messages:
            str_ts = message[&#34;ts&#34;]
            data = &#39;{&#34;channel&#34;:&#34;&#39; + str_channel + &#39;&#34;, &#34;ts&#34;:&#34;&#39; + str_ts + &#39;&#34;}&#39;
            requests.post(
                &#34;https://slack.com/api/chat.delete&#34;,
                headers=NotifBot.dict_headers,
                data=data,
            )
            time.sleep(0.01)

        # lst_messages = self.get_list_messages(str_channel, bl_public=bl_public)
        # if len(lst_messages) &gt; 0:
        #     self.purge_chat(str_channel=str_channel, str_user=str_user, bl_public=bl_public)

    def pop_chat(
        self,
        str_channel: Optional[str] = None,
        str_user: Optional[str] = None,
        index: SupportsIndex = 0,
        bl_public: Optional[bool] = False,
    ) -&gt; None:
        &#34;&#34;&#34;Delete one message by index.

        Parameters
        ----------
        str_channel: str
            The ID of the user or the public channel.
        str_user : str
            If the channel ID is unknown then the user&#39;s name can be used to get it.
        index: int
            The index of the message to delete (starting at the latest).
        bl_public: boolean
            Is the channel public or not.
        &#34;&#34;&#34;
        # If the channel ID is unknown then the user&#39;s name can be used to get it.
        if str_channel is None:
            str_channel = self.get_user_id(str_user)

        # Getting the list of all message on the channel.
        lst_messages = self.get_list_messages(str_channel, bl_public=bl_public)

        # To delete a specific message, we need its time stamp.
        str_ts = lst_messages[index][&#34;ts&#34;]
        data = &#39;{&#34;channel&#34;:&#34;&#39; + str_channel + &#39;&#34;, &#34;ts&#34;:&#34;&#39; + str_ts + &#39;&#34;}&#39;
        requests.post(
            &#34;https://slack.com/api/chat.delete&#34;,
            headers=NotifBot.dict_headers,
            data=data,
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="notifbot.notifbot.NotifBot"><code class="flex name class">
<span>class <span class="ident">NotifBot</span></span>
</code></dt>
<dd>
<div class="desc"><p>Pour créer un objet de notifications.</p>
<h2 id="class-attributes">Class Attributes</h2>
<p>str_botauth: str
Slack Bot Authentification Token. Retreived from environement variables.
dict_headers: dict
Simple formatted header used to querry slack API.</p>
<h2 id="instance-attributes">Instance Attributes</h2>
<p>lst_users: list
A list of all users and associated channels, also public channels. Each user is represented in a dictionnary
with basic information and the ID used to send a message.
dict_sbars: dict
A dictionnary used to store and manage multiple progress bars.</p>
<p>Initialize a notifier.</p>
<p>Creating an instance of a notifier instead of using exclusively class methods allow to keep track of
progress bars, and also load the list of users and channels only once.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotifBot:
    &#34;&#34;&#34;Pour créer un objet de notifications.

    Class Attributes
    ----------------
    str_botauth: str
        Slack Bot Authentification Token. Retreived from environement variables.
    dict_headers: dict
        Simple formatted header used to querry slack API.

    Instance Attributes
    -------------------
    lst_users: list
        A list of all users and associated channels, also public channels. Each user is represented in a dictionnary
        with basic information and the ID used to send a message.
    dict_sbars: dict
        A dictionnary used to store and manage multiple progress bars.
    &#34;&#34;&#34;

    str_botauth: str = os.environ[&#34;BOTAUTH_TOKEN&#34;]
    dict_headers: dict[str, str] = {
        &#34;Authorization&#34;: f&#34;Bearer {str_botauth}&#34;,
        &#34;Content-type&#34;: &#34;application/json&#34;,
    }

    # =====================================================================================================================
    # Initialisation.
    # =====================================================================================================================

    def __init__(self):
        &#34;&#34;&#34;Initialize a notifier.

        Creating an instance of a notifier instead of using exclusively class methods allow to keep track of
        progress bars, and also load the list of users and channels only once.
        &#34;&#34;&#34;
        # Initialisation of the attributes.
        self.lst_users: list[dict[Any, Any]] = list()
        self.dict_sbars: dict[str, Any] = {}

        # Setting the user list.
        self._set_users()
        self._set_channels()
        self._set_public_channels()

    # =====================================================================================================================
    # Simple class method to send a message
    # =====================================================================================================================

    @hybridmethod
    def notify(cls, str_message: str, str_channel: str, str_user: Optional[str] = None) -&gt; None:
        &#34;&#34;&#34;Allow to send a message via the slack API.

        This is a classmethod, it can be used to send a one-shot notification. More complex usage should require
        to declare an instance NotifBot. The &#39;str_user&#39; is here because hybridmethods need to have the same arguments
        for all their versions, but it cannot be used in the class method version.

        Parameters
        ----------
        str_message: str
            The message to send.
        str_channel: str
            The specific ID of the channel where to send the message.
        str_user: str
            Not in use in this version of the function. Default is None.
        &#34;&#34;&#34;
        data: str = f&#39;{{&#34;channel&#34;:&#34;{str_channel}&#34;, &#34;text&#34;:&#34;{str_message}&#34;}}&#39;
        requests.post(
            &#34;https://slack.com/api/chat.postMessage&#34;,
            headers=NotifBot.dict_headers,
            data=data,
        )

    # =====================================================================================================================
    # Setters / Getters
    # =====================================================================================================================

    def _set_users(self) -&gt; None:
        &#34;&#34;&#34;Initialize the list of users.&#34;&#34;&#34;
        # Getting the users.list from slack API and parsing the result.
        response: requests.models.Response = requests.post(&#34;https://slack.com/api/users.list&#34;, headers=NotifBot.dict_headers)
        res: list[dict[str, Any]] = json.loads(response.content.decode(&#34;utf-8&#34;))[&#34;members&#34;]

        # Storing all important information in a list of dictionnaries.
        self.lst_users = [
            {
                &#34;ID&#34;: elt[&#34;id&#34;],
                &#34;Team_ID&#34;: elt[&#34;team_id&#34;],
                &#34;Name&#34;: elt[&#34;name&#34;],
                &#34;Real_name&#34;: elt[&#34;real_name&#34;],
                &#34;Channel&#34;: np.nan,
            }
            if &#34;real_name&#34; in elt.keys()
            else {
                &#34;ID&#34;: elt[&#34;id&#34;],
                &#34;Team_ID&#34;: elt[&#34;team_id&#34;],
                &#34;Name&#34;: elt[&#34;name&#34;],
                &#34;Real_name&#34;: np.nan,
                &#34;Channel&#34;: np.nan,
            }
            for elt in res
        ]

    def _set_channels(self) -&gt; None:
        &#34;&#34;&#34;Add, for each user, the channel to send them messages.&#34;&#34;&#34;
        # Getting the im.list from the slack API and parsing the result.
        response: requests.models.Response = requests.post(
            &#34;https://slack.com/api/conversations.list?types=im&#34;,
            headers=NotifBot.dict_headers,
        )
        res: list[dict[str, Any]] = json.loads(response.content.decode(&#34;utf-8&#34;))[&#34;channels&#34;]

        lst_channels: list[dict[str, str]] = [{&#34;ID&#34;: elt[&#34;user&#34;], &#34;Channel&#34;: elt[&#34;id&#34;]} for elt in res]

        # For each channel, we look up a user with the same ID, when their is a match, the channel is set
        # in the list of users.
        for channel in lst_channels:
            for user in self.lst_users:
                if user[&#34;ID&#34;] == channel[&#34;ID&#34;]:
                    user[&#34;Channel&#34;] = channel[&#34;Channel&#34;]

    def _set_public_channels(self) -&gt; None:
        &#34;&#34;&#34;Add every public channel.&#34;&#34;&#34;
        # Getting the channels.list from the slack API and parsing the result.
        response: requests.models.Response = requests.post(&#34;https://slack.com/api/conversations.list&#34;, headers=NotifBot.dict_headers)
        res: list[dict[str, Any]] = json.loads(response.content.decode(&#34;utf-8&#34;))[&#34;channels&#34;]

        # Storgin everything in a dictionnary.
        lst_public_channels: list[dict[str, str]] = [
            {
                &#34;ID&#34;: elt[&#34;created&#34;],
                &#34;Name&#34;: elt[&#34;name_normalized&#34;],
                &#34;Real_name&#34;: elt[&#34;name&#34;],
                &#34;Channel&#34;: elt[&#34;id&#34;],
            }
            for elt in res
        ]

        # The dictionnary is added to the list of users, the keys to search and to get a channel ID are the same.
        self.lst_users = self.lst_users + lst_public_channels

    # =====================================================================================================================
    # Getting channels and messages
    # =====================================================================================================================

    def get_list_messages(
        self,
        str_channel: Optional[str] = None,
        str_user: Optional[str] = None,
        bl_public: Optional[bool] = False,
    ) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Retreive the list of messages on a channel. Used mostly to purge a channel.

        Parameters
        ----------
        str_channel : str, optional
            The channel ID. The default is None.
        str_user : str, optional
            The name of the user. The default is None.
        bl_public: boolean
            Is the channel public or not.

        Returns
        -------
        dict_messages : dict
            A dictionnary with every message in the channel.
        &#34;&#34;&#34;
        # If a channel ID is not provided, we use the user name to get a channel ID.
        if str_channel is None:
            str_channel = self.get_user_id(str_user)

        # Retreiving the messages with slack API.
        str_token: str = os.environ[&#34;OAUTH_TOKEN&#34;] if bl_public else NotifBot.str_botauth

        response: requests.models.Response = requests.post(
            f&#34;https://slack.com/api/conversations.history?token={str_token}&amp;channel={str_channel}&#34;
        )
        dict_messages: list[dict[str, Any]] = json.loads(response.content.decode(&#34;utf-8&#34;))[&#34;messages&#34;]

        return dict_messages

    def get_user_id(self, str_user: Optional[str] = None) -&gt; str:
        &#34;&#34;&#34;Get a user&#39;s ID from their name.

        Parameters
        ----------
        str_user : str
            The user&#39;s name.

        Returns
        -------
        str_channel : str
            The channel ID associated to the user.
        &#34;&#34;&#34;
        # We search trough the user list with fuzzysearch, retreiving several possible matchs.
        lst_user_names: list[str] = [elt[&#34;Real_name&#34;] for elt in self.lst_users if isinstance(elt[&#34;Real_name&#34;], str)]
        lst_best_names: list[str] = process.extractBests(str_user, lst_user_names, score_cutoff=80)

        # If we get more than one match, the user is prompted to pick the right one.
        if len(lst_best_names) &gt; 1:
            print(f&#34;Serveral match for the name {str_user}.&#34;)
            for i in range(0, len(lst_best_names)):
                print(f&#34;{str(i + 1)} : {lst_best_names[i][0]}&#34;)
            print(f&#34;{str(i + 2)} : Quit&#34;)
            index_name: int = im.force_read(im.read_numeric, &#34;Your pick : &#34;, True, 1, len(lst_best_names) + 1)
            if index_name == (i + 2):
                raise SlackbotException(f&#34;No match for {str_user} user.&#34;)
            str_user = lst_best_names[index_name - 1][0]
        # If their is only one match, then we get their channel ID.
        elif len(lst_best_names) == 1:
            str_user = lst_best_names[0][0]
        # If no match, then error.
        else:
            raise SlackbotException(f&#34;No match for {str_user} user.&#34;)

        # Looking up the channel ID in the user list.
        str_channel: str = [elt[&#34;Channel&#34;] for elt in self.lst_users if elt[&#34;Real_name&#34;] == str_user][0]

        # If the user exist but no channel is open with them.
        if not isinstance(str_channel, str):
            raise SlackbotException(f&#34;No channel openned with {str_user}.&#34;)

        return str_channel

    # =====================================================================================================================
    # Sending and deleting messages
    # =====================================================================================================================

    @notify.instancemethod
    def notify(
        self,
        str_message: str,
        str_channel: Optional[str] = None,
        str_user: Optional[str] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Send a message to a user or on a channel.

        Parameters
        ----------
        str_message: str
            The message to send.
        str_channel: str
            The ID of the user or the public channel.
        str_user : str
            If the channel ID is unknown then the user&#39;s name can be used to get it.
        &#34;&#34;&#34;
        # If the channel ID is unknown then the user&#39;s name can be used to get it.
        if str_channel is None:
            str_channel = self.get_user_id(str_user)

        # Send a message through the slack API.
        data: str = f&#39;{{&#34;channel&#34;:&#34;{str_channel}&#34;, &#34;text&#34;:&#34;{str_message}&#34;}}&#39;
        requests.post(
            &#34;https://slack.com/api/chat.postMessage&#34;,
            headers=NotifBot.dict_headers,
            data=data,
        )

    def progress(
        self,
        str_name: str,
        str_title: str,
        int_total: int,
        str_channel: Optional[str] = None,
        str_user: Optional[str] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Create a progress bar.

        Parameters
        ----------
        str_name: str
            The name of the progress bar. Used to reference it once created.
        str_title: str
            The displayed title of the progress bar.
        str_channel: str
            The ID of the user or the public channel.
        str_user : str
            If the channel ID is unknown then the user&#39;s name can be used to get it.
        &#34;&#34;&#34;
        # If the channel ID is unknown then the user&#39;s name can be used to get it.
        if str_channel is None:
            str_channel = self.get_user_id(str_user)

        # Adding the progress bar with it&#39;s title and total.
        progress_bar = SlackProgress(NotifBot.str_botauth, str_channel)
        self.dict_sbars[str_name] = {
            &#34;pbar&#34;: progress_bar.new(total=int_total),
            &#34;title&#34;: str_title,
        }
        self.dict_sbars[str_name][&#34;pbar&#34;].log(str_title)

    def progress_set_title(self, str_name: str, str_title: str) -&gt; None:
        &#34;&#34;&#34;Set the progress bar title. Used mostly to change it.

        Parameters
        ----------
        str_name: str
            The name of the progress bar. Used to reference it once created.
        str_title: str
            The displayed title of the progress bar.
        &#34;&#34;&#34;
        self.dict_sbars[str_name][&#34;title&#34;] = str_title

    def progress_update(self, str_name: str, int_value: int) -&gt; None:
        &#34;&#34;&#34;Update a prgress bar.

        Parameters
        ----------
        str_name: str
            The name of the progress bar. Used to reference it once created.
        int_value: int
            The value to add.
        &#34;&#34;&#34;
        self.dict_sbars[str_name][&#34;pbar&#34;].pos = round(
            (self.dict_sbars[str_name][&#34;pbar&#34;].pos + (int_value * 100 / self.dict_sbars[str_name][&#34;pbar&#34;].total)),
            2,
        )

    def progress_value(self, str_name: str, int_value: int):
        &#34;&#34;&#34;Set the progress bar to a specific value.

        Parameters
        ----------
        str_name: str
            The name of the progress bar.
        int_value: int
            The value where to set the progress bar.
        &#34;&#34;&#34;
        self.dict_sbars[str_name][&#34;pbar&#34;].pos = round((int_value * 100 / self.dict_sbars[str_name][&#34;pbar&#34;].total), 2)

    def progress_log(self, str_name: str, str_log: str, bl_stack_log: Optional[bool] = True):
        &#34;&#34;&#34;Log an event into the progress bar (display under the title in slack).

        Parameters
        ----------
        str_name: str
            The name of the progress bar.
        str_log : str
            The message to log.
        bl_stack_log: bool
            Should we erease all previous logged messages.
        &#34;&#34;&#34;
        # The message is added to the progress bar.
        self.dict_sbars[str_name][&#34;pbar&#34;].log(f&#34;{self.dict_sbars[str_name][&#39;title&#39;]} - {str_log}&#34;)

        # If we decide so, every logged message added before the new one is deleted.
        if not bl_stack_log:
            self.dict_sbars[str_name][&#34;pbar&#34;]._msg_log = [self.dict_sbars[str_name][&#34;pbar&#34;]._msg_log[-1]]
            self.dict_sbars[str_name][&#34;pbar&#34;]._update()

    def progress_delete(self, str_name: str) -&gt; None:
        &#34;&#34;&#34;Delete a progress bar.

        Parameters
        ----------
        str_name: str
            The name of the progress bar.
        &#34;&#34;&#34;
        # In order to delete a message (a progress bar in this case), we need its time stamp
        str_ts = self.dict_sbars[str_name][&#34;pbar&#34;].msg_ts
        data = f&#34;&#34;&#34;{{&#34;channel&#34;:&#34;{self.dict_sbars[str_name][&#39;pbar&#39;].channel_id}&#34;, &#34;ts&#34;:&#34;{str_ts}&#34;}}&#34;&#34;&#34;
        requests.post(
            &#34;https://slack.com/api/chat.delete&#34;,
            headers=NotifBot.dict_headers,
            data=data,
        )

    def purge_chat(
        self,
        str_channel: Optional[str] = None,
        str_user: Optional[str] = None,
        bl_public: Optional[bool] = False,
    ) -&gt; None:
        &#34;&#34;&#34;Purge an entier chat.

        Parameters
        ----------
        str_channel: str
            The ID of the user or the public channel.
        str_user : str
            If the channel ID is unknown then the user&#39;s name can be used to get it.
        bl_public: boolean
            Is the channel public or not.
        &#34;&#34;&#34;
        # If the channel ID is unknown then the user&#39;s name can be used to get it.
        if str_channel is None:
            str_channel = self.get_user_id(str_user)

        # Getting the list of all message on the channel.
        lst_messages = self.get_list_messages(str_channel, bl_public=bl_public)

        # For each message, we use its time stamp to delete it.
        for message in lst_messages:
            str_ts = message[&#34;ts&#34;]
            data = &#39;{&#34;channel&#34;:&#34;&#39; + str_channel + &#39;&#34;, &#34;ts&#34;:&#34;&#39; + str_ts + &#39;&#34;}&#39;
            requests.post(
                &#34;https://slack.com/api/chat.delete&#34;,
                headers=NotifBot.dict_headers,
                data=data,
            )
            time.sleep(0.01)

        # lst_messages = self.get_list_messages(str_channel, bl_public=bl_public)
        # if len(lst_messages) &gt; 0:
        #     self.purge_chat(str_channel=str_channel, str_user=str_user, bl_public=bl_public)

    def pop_chat(
        self,
        str_channel: Optional[str] = None,
        str_user: Optional[str] = None,
        index: SupportsIndex = 0,
        bl_public: Optional[bool] = False,
    ) -&gt; None:
        &#34;&#34;&#34;Delete one message by index.

        Parameters
        ----------
        str_channel: str
            The ID of the user or the public channel.
        str_user : str
            If the channel ID is unknown then the user&#39;s name can be used to get it.
        index: int
            The index of the message to delete (starting at the latest).
        bl_public: boolean
            Is the channel public or not.
        &#34;&#34;&#34;
        # If the channel ID is unknown then the user&#39;s name can be used to get it.
        if str_channel is None:
            str_channel = self.get_user_id(str_user)

        # Getting the list of all message on the channel.
        lst_messages = self.get_list_messages(str_channel, bl_public=bl_public)

        # To delete a specific message, we need its time stamp.
        str_ts = lst_messages[index][&#34;ts&#34;]
        data = &#39;{&#34;channel&#34;:&#34;&#39; + str_channel + &#39;&#34;, &#34;ts&#34;:&#34;&#39; + str_ts + &#39;&#34;}&#39;
        requests.post(
            &#34;https://slack.com/api/chat.delete&#34;,
            headers=NotifBot.dict_headers,
            data=data,
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="notifbot.notifbot.NotifBot.dict_headers"><code class="name">var <span class="ident">dict_headers</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="notifbot.notifbot.NotifBot.str_botauth"><code class="name">var <span class="ident">str_botauth</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="notifbot.notifbot.NotifBot.notify"><code class="name flex">
<span>def <span class="ident">notify</span></span>(<span>str_message: str, str_channel: str, str_user: Optional[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Allow to send a message via the slack API.</p>
<p>This is a classmethod, it can be used to send a one-shot notification. More complex usage should require
to declare an instance NotifBot. The 'str_user' is here because hybridmethods need to have the same arguments
for all their versions, but it cannot be used in the class method version.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>str_message</code></strong> :&ensp;<code>str</code></dt>
<dd>The message to send.</dd>
<dt><strong><code>str_channel</code></strong> :&ensp;<code>str</code></dt>
<dd>The specific ID of the channel where to send the message.</dd>
<dt><strong><code>str_user</code></strong> :&ensp;<code>str</code></dt>
<dd>Not in use in this version of the function. Default is None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@hybridmethod
def notify(cls, str_message: str, str_channel: str, str_user: Optional[str] = None) -&gt; None:
    &#34;&#34;&#34;Allow to send a message via the slack API.

    This is a classmethod, it can be used to send a one-shot notification. More complex usage should require
    to declare an instance NotifBot. The &#39;str_user&#39; is here because hybridmethods need to have the same arguments
    for all their versions, but it cannot be used in the class method version.

    Parameters
    ----------
    str_message: str
        The message to send.
    str_channel: str
        The specific ID of the channel where to send the message.
    str_user: str
        Not in use in this version of the function. Default is None.
    &#34;&#34;&#34;
    data: str = f&#39;{{&#34;channel&#34;:&#34;{str_channel}&#34;, &#34;text&#34;:&#34;{str_message}&#34;}}&#39;
    requests.post(
        &#34;https://slack.com/api/chat.postMessage&#34;,
        headers=NotifBot.dict_headers,
        data=data,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="notifbot.notifbot.NotifBot.get_list_messages"><code class="name flex">
<span>def <span class="ident">get_list_messages</span></span>(<span>self, str_channel: Optional[str] = None, str_user: Optional[str] = None, bl_public: Optional[bool] = False) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retreive the list of messages on a channel. Used mostly to purge a channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>str_channel</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The channel ID. The default is None.</dd>
<dt><strong><code>str_user</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the user. The default is None.</dd>
<dt><strong><code>bl_public</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Is the channel public or not.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict_messages</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionnary with every message in the channel.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list_messages(
    self,
    str_channel: Optional[str] = None,
    str_user: Optional[str] = None,
    bl_public: Optional[bool] = False,
) -&gt; list[dict[str, Any]]:
    &#34;&#34;&#34;Retreive the list of messages on a channel. Used mostly to purge a channel.

    Parameters
    ----------
    str_channel : str, optional
        The channel ID. The default is None.
    str_user : str, optional
        The name of the user. The default is None.
    bl_public: boolean
        Is the channel public or not.

    Returns
    -------
    dict_messages : dict
        A dictionnary with every message in the channel.
    &#34;&#34;&#34;
    # If a channel ID is not provided, we use the user name to get a channel ID.
    if str_channel is None:
        str_channel = self.get_user_id(str_user)

    # Retreiving the messages with slack API.
    str_token: str = os.environ[&#34;OAUTH_TOKEN&#34;] if bl_public else NotifBot.str_botauth

    response: requests.models.Response = requests.post(
        f&#34;https://slack.com/api/conversations.history?token={str_token}&amp;channel={str_channel}&#34;
    )
    dict_messages: list[dict[str, Any]] = json.loads(response.content.decode(&#34;utf-8&#34;))[&#34;messages&#34;]

    return dict_messages</code></pre>
</details>
</dd>
<dt id="notifbot.notifbot.NotifBot.get_user_id"><code class="name flex">
<span>def <span class="ident">get_user_id</span></span>(<span>self, str_user: Optional[str] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get a user's ID from their name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>str_user</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str_channel</code></strong> :&ensp;<code>str</code></dt>
<dd>The channel ID associated to the user.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_id(self, str_user: Optional[str] = None) -&gt; str:
    &#34;&#34;&#34;Get a user&#39;s ID from their name.

    Parameters
    ----------
    str_user : str
        The user&#39;s name.

    Returns
    -------
    str_channel : str
        The channel ID associated to the user.
    &#34;&#34;&#34;
    # We search trough the user list with fuzzysearch, retreiving several possible matchs.
    lst_user_names: list[str] = [elt[&#34;Real_name&#34;] for elt in self.lst_users if isinstance(elt[&#34;Real_name&#34;], str)]
    lst_best_names: list[str] = process.extractBests(str_user, lst_user_names, score_cutoff=80)

    # If we get more than one match, the user is prompted to pick the right one.
    if len(lst_best_names) &gt; 1:
        print(f&#34;Serveral match for the name {str_user}.&#34;)
        for i in range(0, len(lst_best_names)):
            print(f&#34;{str(i + 1)} : {lst_best_names[i][0]}&#34;)
        print(f&#34;{str(i + 2)} : Quit&#34;)
        index_name: int = im.force_read(im.read_numeric, &#34;Your pick : &#34;, True, 1, len(lst_best_names) + 1)
        if index_name == (i + 2):
            raise SlackbotException(f&#34;No match for {str_user} user.&#34;)
        str_user = lst_best_names[index_name - 1][0]
    # If their is only one match, then we get their channel ID.
    elif len(lst_best_names) == 1:
        str_user = lst_best_names[0][0]
    # If no match, then error.
    else:
        raise SlackbotException(f&#34;No match for {str_user} user.&#34;)

    # Looking up the channel ID in the user list.
    str_channel: str = [elt[&#34;Channel&#34;] for elt in self.lst_users if elt[&#34;Real_name&#34;] == str_user][0]

    # If the user exist but no channel is open with them.
    if not isinstance(str_channel, str):
        raise SlackbotException(f&#34;No channel openned with {str_user}.&#34;)

    return str_channel</code></pre>
</details>
</dd>
<dt id="notifbot.notifbot.NotifBot.pop_chat"><code class="name flex">
<span>def <span class="ident">pop_chat</span></span>(<span>self, str_channel: Optional[str] = None, str_user: Optional[str] = None, index: <class 'SupportsIndex'> = 0, bl_public: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete one message by index.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>str_channel</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user or the public channel.</dd>
<dt><strong><code>str_user</code></strong> :&ensp;<code>str</code></dt>
<dd>If the channel ID is unknown then the user's name can be used to get it.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the message to delete (starting at the latest).</dd>
<dt><strong><code>bl_public</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Is the channel public or not.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_chat(
    self,
    str_channel: Optional[str] = None,
    str_user: Optional[str] = None,
    index: SupportsIndex = 0,
    bl_public: Optional[bool] = False,
) -&gt; None:
    &#34;&#34;&#34;Delete one message by index.

    Parameters
    ----------
    str_channel: str
        The ID of the user or the public channel.
    str_user : str
        If the channel ID is unknown then the user&#39;s name can be used to get it.
    index: int
        The index of the message to delete (starting at the latest).
    bl_public: boolean
        Is the channel public or not.
    &#34;&#34;&#34;
    # If the channel ID is unknown then the user&#39;s name can be used to get it.
    if str_channel is None:
        str_channel = self.get_user_id(str_user)

    # Getting the list of all message on the channel.
    lst_messages = self.get_list_messages(str_channel, bl_public=bl_public)

    # To delete a specific message, we need its time stamp.
    str_ts = lst_messages[index][&#34;ts&#34;]
    data = &#39;{&#34;channel&#34;:&#34;&#39; + str_channel + &#39;&#34;, &#34;ts&#34;:&#34;&#39; + str_ts + &#39;&#34;}&#39;
    requests.post(
        &#34;https://slack.com/api/chat.delete&#34;,
        headers=NotifBot.dict_headers,
        data=data,
    )</code></pre>
</details>
</dd>
<dt id="notifbot.notifbot.NotifBot.progress"><code class="name flex">
<span>def <span class="ident">progress</span></span>(<span>self, str_name: str, str_title: str, int_total: int, str_channel: Optional[str] = None, str_user: Optional[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Create a progress bar.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>str_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the progress bar. Used to reference it once created.</dd>
<dt><strong><code>str_title</code></strong> :&ensp;<code>str</code></dt>
<dd>The displayed title of the progress bar.</dd>
<dt><strong><code>str_channel</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user or the public channel.</dd>
<dt><strong><code>str_user</code></strong> :&ensp;<code>str</code></dt>
<dd>If the channel ID is unknown then the user's name can be used to get it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress(
    self,
    str_name: str,
    str_title: str,
    int_total: int,
    str_channel: Optional[str] = None,
    str_user: Optional[str] = None,
) -&gt; None:
    &#34;&#34;&#34;Create a progress bar.

    Parameters
    ----------
    str_name: str
        The name of the progress bar. Used to reference it once created.
    str_title: str
        The displayed title of the progress bar.
    str_channel: str
        The ID of the user or the public channel.
    str_user : str
        If the channel ID is unknown then the user&#39;s name can be used to get it.
    &#34;&#34;&#34;
    # If the channel ID is unknown then the user&#39;s name can be used to get it.
    if str_channel is None:
        str_channel = self.get_user_id(str_user)

    # Adding the progress bar with it&#39;s title and total.
    progress_bar = SlackProgress(NotifBot.str_botauth, str_channel)
    self.dict_sbars[str_name] = {
        &#34;pbar&#34;: progress_bar.new(total=int_total),
        &#34;title&#34;: str_title,
    }
    self.dict_sbars[str_name][&#34;pbar&#34;].log(str_title)</code></pre>
</details>
</dd>
<dt id="notifbot.notifbot.NotifBot.progress_delete"><code class="name flex">
<span>def <span class="ident">progress_delete</span></span>(<span>self, str_name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a progress bar.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>str_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the progress bar.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress_delete(self, str_name: str) -&gt; None:
    &#34;&#34;&#34;Delete a progress bar.

    Parameters
    ----------
    str_name: str
        The name of the progress bar.
    &#34;&#34;&#34;
    # In order to delete a message (a progress bar in this case), we need its time stamp
    str_ts = self.dict_sbars[str_name][&#34;pbar&#34;].msg_ts
    data = f&#34;&#34;&#34;{{&#34;channel&#34;:&#34;{self.dict_sbars[str_name][&#39;pbar&#39;].channel_id}&#34;, &#34;ts&#34;:&#34;{str_ts}&#34;}}&#34;&#34;&#34;
    requests.post(
        &#34;https://slack.com/api/chat.delete&#34;,
        headers=NotifBot.dict_headers,
        data=data,
    )</code></pre>
</details>
</dd>
<dt id="notifbot.notifbot.NotifBot.progress_log"><code class="name flex">
<span>def <span class="ident">progress_log</span></span>(<span>self, str_name: str, str_log: str, bl_stack_log: Optional[bool] = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Log an event into the progress bar (display under the title in slack).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>str_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the progress bar.</dd>
<dt><strong><code>str_log</code></strong> :&ensp;<code>str</code></dt>
<dd>The message to log.</dd>
<dt><strong><code>bl_stack_log</code></strong> :&ensp;<code>bool</code></dt>
<dd>Should we erease all previous logged messages.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress_log(self, str_name: str, str_log: str, bl_stack_log: Optional[bool] = True):
    &#34;&#34;&#34;Log an event into the progress bar (display under the title in slack).

    Parameters
    ----------
    str_name: str
        The name of the progress bar.
    str_log : str
        The message to log.
    bl_stack_log: bool
        Should we erease all previous logged messages.
    &#34;&#34;&#34;
    # The message is added to the progress bar.
    self.dict_sbars[str_name][&#34;pbar&#34;].log(f&#34;{self.dict_sbars[str_name][&#39;title&#39;]} - {str_log}&#34;)

    # If we decide so, every logged message added before the new one is deleted.
    if not bl_stack_log:
        self.dict_sbars[str_name][&#34;pbar&#34;]._msg_log = [self.dict_sbars[str_name][&#34;pbar&#34;]._msg_log[-1]]
        self.dict_sbars[str_name][&#34;pbar&#34;]._update()</code></pre>
</details>
</dd>
<dt id="notifbot.notifbot.NotifBot.progress_set_title"><code class="name flex">
<span>def <span class="ident">progress_set_title</span></span>(<span>self, str_name: str, str_title: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the progress bar title. Used mostly to change it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>str_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the progress bar. Used to reference it once created.</dd>
<dt><strong><code>str_title</code></strong> :&ensp;<code>str</code></dt>
<dd>The displayed title of the progress bar.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress_set_title(self, str_name: str, str_title: str) -&gt; None:
    &#34;&#34;&#34;Set the progress bar title. Used mostly to change it.

    Parameters
    ----------
    str_name: str
        The name of the progress bar. Used to reference it once created.
    str_title: str
        The displayed title of the progress bar.
    &#34;&#34;&#34;
    self.dict_sbars[str_name][&#34;title&#34;] = str_title</code></pre>
</details>
</dd>
<dt id="notifbot.notifbot.NotifBot.progress_update"><code class="name flex">
<span>def <span class="ident">progress_update</span></span>(<span>self, str_name: str, int_value: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update a prgress bar.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>str_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the progress bar. Used to reference it once created.</dd>
<dt><strong><code>int_value</code></strong> :&ensp;<code>int</code></dt>
<dd>The value to add.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress_update(self, str_name: str, int_value: int) -&gt; None:
    &#34;&#34;&#34;Update a prgress bar.

    Parameters
    ----------
    str_name: str
        The name of the progress bar. Used to reference it once created.
    int_value: int
        The value to add.
    &#34;&#34;&#34;
    self.dict_sbars[str_name][&#34;pbar&#34;].pos = round(
        (self.dict_sbars[str_name][&#34;pbar&#34;].pos + (int_value * 100 / self.dict_sbars[str_name][&#34;pbar&#34;].total)),
        2,
    )</code></pre>
</details>
</dd>
<dt id="notifbot.notifbot.NotifBot.progress_value"><code class="name flex">
<span>def <span class="ident">progress_value</span></span>(<span>self, str_name: str, int_value: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the progress bar to a specific value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>str_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the progress bar.</dd>
<dt><strong><code>int_value</code></strong> :&ensp;<code>int</code></dt>
<dd>The value where to set the progress bar.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress_value(self, str_name: str, int_value: int):
    &#34;&#34;&#34;Set the progress bar to a specific value.

    Parameters
    ----------
    str_name: str
        The name of the progress bar.
    int_value: int
        The value where to set the progress bar.
    &#34;&#34;&#34;
    self.dict_sbars[str_name][&#34;pbar&#34;].pos = round((int_value * 100 / self.dict_sbars[str_name][&#34;pbar&#34;].total), 2)</code></pre>
</details>
</dd>
<dt id="notifbot.notifbot.NotifBot.purge_chat"><code class="name flex">
<span>def <span class="ident">purge_chat</span></span>(<span>self, str_channel: Optional[str] = None, str_user: Optional[str] = None, bl_public: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Purge an entier chat.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>str_channel</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user or the public channel.</dd>
<dt><strong><code>str_user</code></strong> :&ensp;<code>str</code></dt>
<dd>If the channel ID is unknown then the user's name can be used to get it.</dd>
<dt><strong><code>bl_public</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Is the channel public or not.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purge_chat(
    self,
    str_channel: Optional[str] = None,
    str_user: Optional[str] = None,
    bl_public: Optional[bool] = False,
) -&gt; None:
    &#34;&#34;&#34;Purge an entier chat.

    Parameters
    ----------
    str_channel: str
        The ID of the user or the public channel.
    str_user : str
        If the channel ID is unknown then the user&#39;s name can be used to get it.
    bl_public: boolean
        Is the channel public or not.
    &#34;&#34;&#34;
    # If the channel ID is unknown then the user&#39;s name can be used to get it.
    if str_channel is None:
        str_channel = self.get_user_id(str_user)

    # Getting the list of all message on the channel.
    lst_messages = self.get_list_messages(str_channel, bl_public=bl_public)

    # For each message, we use its time stamp to delete it.
    for message in lst_messages:
        str_ts = message[&#34;ts&#34;]
        data = &#39;{&#34;channel&#34;:&#34;&#39; + str_channel + &#39;&#34;, &#34;ts&#34;:&#34;&#39; + str_ts + &#39;&#34;}&#39;
        requests.post(
            &#34;https://slack.com/api/chat.delete&#34;,
            headers=NotifBot.dict_headers,
            data=data,
        )
        time.sleep(0.01)

    # lst_messages = self.get_list_messages(str_channel, bl_public=bl_public)
    # if len(lst_messages) &gt; 0:
    #     self.purge_chat(str_channel=str_channel, str_user=str_user, bl_public=bl_public)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="notifbot.notifbot.SlackbotException"><code class="flex name class">
<span>class <span class="ident">SlackbotException</span></span>
<span>(</span><span>message)</span>
</code></dt>
<dd>
<div class="desc"><p>Slackbot erros.</p>
<p>Error constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SlackbotException(Exception):
    &#34;&#34;&#34;Slackbot erros.&#34;&#34;&#34;

    def __init__(self, message):
        &#34;&#34;&#34;Error constructor.&#34;&#34;&#34;
        super(Exception, self).__init__(message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="notifbot.notifbot.hybridmethod"><code class="flex name class">
<span>class <span class="ident">hybridmethod</span></span>
<span>(</span><span>fclass, finstance=None, doc=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Allow to declare a class and instance version of the same method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class hybridmethod:
    &#34;&#34;&#34;Allow to declare a class and instance version of the same method.&#34;&#34;&#34;

    def __init__(self, fclass, finstance=None, doc=None):
        self.fclass = fclass
        self.finstance = finstance
        self.__doc__ = doc or fclass.__doc__
        # support use on abstract base classes
        self.__isabstractmethod__ = bool(getattr(fclass, &#34;__isabstractmethod__&#34;, False))

    def classmethod(self, fclass):
        &#34;&#34;&#34;Class method version of the function.&#34;&#34;&#34;
        return type(self)(fclass, self.finstance, None)

    def instancemethod(self, finstance):
        &#34;&#34;&#34;Instance method version of the function.&#34;&#34;&#34;
        return type(self)(self.fclass, finstance, self.__doc__)

    def __get__(self, instance, cls):
        &#34;&#34;&#34;Retreive the right version.&#34;&#34;&#34;
        if instance is None or self.finstance is None:
            # either bound to the class, or no instance method available
            return self.fclass.__get__(cls, None)
        return self.finstance.__get__(instance, cls)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="notifbot.notifbot.hybridmethod.classmethod"><code class="name flex">
<span>def <span class="ident">classmethod</span></span>(<span>self, fclass)</span>
</code></dt>
<dd>
<div class="desc"><p>Class method version of the function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def classmethod(self, fclass):
    &#34;&#34;&#34;Class method version of the function.&#34;&#34;&#34;
    return type(self)(fclass, self.finstance, None)</code></pre>
</details>
</dd>
<dt id="notifbot.notifbot.hybridmethod.instancemethod"><code class="name flex">
<span>def <span class="ident">instancemethod</span></span>(<span>self, finstance)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance method version of the function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def instancemethod(self, finstance):
    &#34;&#34;&#34;Instance method version of the function.&#34;&#34;&#34;
    return type(self)(self.fclass, finstance, self.__doc__)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="notifbot" href="index.html">notifbot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="notifbot.notifbot.NotifBot" href="#notifbot.notifbot.NotifBot">NotifBot</a></code></h4>
<ul class="two-column">
<li><code><a title="notifbot.notifbot.NotifBot.dict_headers" href="#notifbot.notifbot.NotifBot.dict_headers">dict_headers</a></code></li>
<li><code><a title="notifbot.notifbot.NotifBot.get_list_messages" href="#notifbot.notifbot.NotifBot.get_list_messages">get_list_messages</a></code></li>
<li><code><a title="notifbot.notifbot.NotifBot.get_user_id" href="#notifbot.notifbot.NotifBot.get_user_id">get_user_id</a></code></li>
<li><code><a title="notifbot.notifbot.NotifBot.notify" href="#notifbot.notifbot.NotifBot.notify">notify</a></code></li>
<li><code><a title="notifbot.notifbot.NotifBot.pop_chat" href="#notifbot.notifbot.NotifBot.pop_chat">pop_chat</a></code></li>
<li><code><a title="notifbot.notifbot.NotifBot.progress" href="#notifbot.notifbot.NotifBot.progress">progress</a></code></li>
<li><code><a title="notifbot.notifbot.NotifBot.progress_delete" href="#notifbot.notifbot.NotifBot.progress_delete">progress_delete</a></code></li>
<li><code><a title="notifbot.notifbot.NotifBot.progress_log" href="#notifbot.notifbot.NotifBot.progress_log">progress_log</a></code></li>
<li><code><a title="notifbot.notifbot.NotifBot.progress_set_title" href="#notifbot.notifbot.NotifBot.progress_set_title">progress_set_title</a></code></li>
<li><code><a title="notifbot.notifbot.NotifBot.progress_update" href="#notifbot.notifbot.NotifBot.progress_update">progress_update</a></code></li>
<li><code><a title="notifbot.notifbot.NotifBot.progress_value" href="#notifbot.notifbot.NotifBot.progress_value">progress_value</a></code></li>
<li><code><a title="notifbot.notifbot.NotifBot.purge_chat" href="#notifbot.notifbot.NotifBot.purge_chat">purge_chat</a></code></li>
<li><code><a title="notifbot.notifbot.NotifBot.str_botauth" href="#notifbot.notifbot.NotifBot.str_botauth">str_botauth</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="notifbot.notifbot.SlackbotException" href="#notifbot.notifbot.SlackbotException">SlackbotException</a></code></h4>
</li>
<li>
<h4><code><a title="notifbot.notifbot.hybridmethod" href="#notifbot.notifbot.hybridmethod">hybridmethod</a></code></h4>
<ul class="">
<li><code><a title="notifbot.notifbot.hybridmethod.classmethod" href="#notifbot.notifbot.hybridmethod.classmethod">classmethod</a></code></li>
<li><code><a title="notifbot.notifbot.hybridmethod.instancemethod" href="#notifbot.notifbot.hybridmethod.instancemethod">instancemethod</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
